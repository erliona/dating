# ==== Project Identity ====
- This is a Telegram Mini App with an API Gateway and multiple Python microservices.
- Stack: Python 3.11+, aiogram 3.x, aiohttp 3.9+, SQLAlchemy 2.x (async), asyncpg, Alembic, PyJWT, bcrypt.
- Infra: Docker + Docker Compose, Traefik 2.x, PostgreSQL 15, Prometheus/Grafana/Loki.
- Frontend: vanilla JS + Telegram WebApp SDK behind Nginx.
- Always respect the existing folder layout: bot/, core/, gateway/, services/*, webapp/, monitoring/, migrations/, scripts/.
- Never hardcode ports. Use envs from .env/.env.example and docker-compose.

# ==== Code Synchronization (CRITICAL) ====
- ALWAYS keep code synchronized between: Local Machine ↔ GitHub ↔ Server
- After ANY code changes: 1) Commit locally 2) Push to GitHub 3) Update server
- Server update: `ssh root@dating.serge.cc "cd /root/dating-microservices && git pull origin main && docker compose restart [affected-services]"`
- Never make changes directly on server - always go through Git workflow
- If server changes are needed, commit them locally first, then sync
- Verify synchronization: check git status, commit hashes, and service health on all three points

# ==== Coding Style (Python) ====
- Use modern Python with full type hints and `from __future__ import annotations`.
- Async first: prefer async/await everywhere; no blocking calls in event loops.
- Use SQLAlchemy 2.0 ORM (async) with explicit `select()` API; avoid legacy 1.x patterns.
- Keep functions focused (< ~50 LOC when reasonable). Prefer pure functions; minimize side effects.
- Logging only via project utilities in core; no `print`.
- Validate inputs at all edges (bot handlers, HTTP handlers); sanitize user text before storage/render.

# ==== Architecture & Boundaries ====
- Gateway is the single public entrypoint. Services talk via gateway/API contracts only.
- Each service owns its DB schema and Alembic migrations; do not mutate other services' tables.
- JWT: verification/refresh only via Auth Service; do not reimplement JWT in other services.
- Media through Media Service; Chat through Chat Service; Discovery encapsulates matching; Admin isolated; Notification handles outbound messages.
- Share code only through core utilities or well-defined client modules; avoid cross-imports between services.

# ==== Bot (aiogram) ====
- Handlers must be thin; move business logic to service layer.
- Use middlewares from `core/middleware` (jwt, metrics, request logging) consistently.
- Never block the bot loop; offload heavy work to background jobs/workers if present.

# ==== HTTP (aiohttp) & Errors ====
- Handlers return typed JSON with a consistent error envelope:
  { "error": { "code": string, "message": string, "details": object? } }
- Map exceptions to sensible 4xx/5xx; do not leak stack traces to clients (log them).

# ==== Database & Migrations ====
- Use explicit transactions with async sessions (one per request when needed).
- Every schema change → Alembic migration; keep migrations reversible and idempotent.
- Prevent N+1 via joined eager loads or batching; confirm with test data and logs.
- **Migration naming**: Use full filename as revision ID (e.g., "007_create_chat_tables" not "007").
- **Migration dependencies**: Always update down_revision to full filename of previous migration.

# ==== Security ====
- No secrets in code. Use env vars; keep `.env.example` in sync.
- Passwords: bcrypt; tokens: PyJWT; follow existing expirations/rotation.
- Validate and sanitize uploaded media metadata and user-generated text.

# ==== Observability ====
- Expose Prometheus metrics via middleware; names like `service_operation_total`, `request_duration_seconds`.
- Structured logs must include service name, request path, correlation/request ID when available.
- Provide `/health` and `/ready` endpoints per service.
- See .cursor/production.rules for deployment and monitoring best practices.

# ==== Frontend (webapp/) ====
- Vanilla JS + Telegram WebApp SDK: small modules, responsive CSS, minimal bundle size.
- Respect Telegram theme/background; avoid blocking calls; use gateway APIs only; attach JWT when required.

# ==== Docker/Compose/Traefik ====
- All services must build & run under `docker-compose` without manual steps.
- Do not change service names/labels without updating Traefik routes.
- Use slim, pinned base images; multi-stage builds; avoid running as root where possible.

# ==== Testing ====
- Use pytest. For new logic add unit tests; for endpoints add integration tests with test DB.
- Keep tests deterministic and fast; use fixtures/factories; mock network calls.
- Maintain/raise coverage thresholds defined in repo configs; add regression tests for fixed bugs.

# ==== Performance & Reliability ====
- Add DB indexes for hot queries via migrations; consider back-pressure friendly designs.
- Timeouts/retries/circuit breakers on inter-service calls where appropriate.
- Paginate list endpoints; cap payload sizes; stream large media via Media Service.

# ==== API Design ====
- Public APIs versioned under `/api/v1/...`. Use nouns for resources; verbs only for RPC-like actions.
- Keep OpenAPI/markdown snippets in `docs/` (or service-local); include request/response examples.

# ==== PR & Docs Conventions ====
- Commits: `<type>(scope): summary` (e.g., `feat(discovery): add mutual likes`).
- PRs must include context, changes, testing notes, rollout/backout plan.
- Update README/TECH_STACK/ROADMAP when adding notable features/services.

# ==== Cursor-Specific Guidance ====
- When generating code, match existing folders/imports; never create new top-level dirs without instruction.
- When adding a new endpoint/handler, generate **all** of:
  1) route/handler (aiohttp),
  2) service-layer function,
  3) repository call (SQLAlchemy),
  4) schema/DTO,
  5) tests,
  6) logging + metrics,
  7) docs snippet.
- When touching DB models, also create an Alembic migration stub and a covering test.
- Prefer incremental edits to existing files; preserve maintainers' comments and structure.

# ==== Git Workflow & Docker ====
- See .cursor/git-flow-and-docker.rules for detailed Git workflow and Docker container management rules.
- Core principle: All code changes must go through git: feature branch → commits → PR → review → merge → CI/CD rebuild.
- Never modify files inside running containers or rely on manual hot-patches.

# ==== Safe Defaults & Guardrails ====
- Never hardcode ports, URLs, or secrets; read from env/config.
- Avoid adding dependencies unless necessary; justify additions in PR description.
- For exploratory chats, do **not** modify files unless explicitly asked (describe steps instead).

# ==== Example Patterns (for the AI to copy) ====
- aiohttp route skeleton:
  ```py
  from aiohttp import web
  from .schemas import MatchRequest, MatchResponse
  from .service import make_match

  async def post_match(request: web.Request) -> web.Response:
      body = await request.json()
      req = MatchRequest.model_validate(body)
      result = await make_match(req, request.app['db'])
      return web.json_response(MatchResponse.model_validate(result).model_dump())
  ```

# ==== Cross-References ====
- For production deployment rules: see .cursor/production.rules
- For troubleshooting and diagnostics: see .cursor/troubleshooting.rules
- For deployment and monitoring: see .cursor/deployment-and-monitoring.rules
- For git flow and docker: see .cursor/git-flow-and-docker.rules