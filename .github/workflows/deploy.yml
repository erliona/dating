name: Deploy

on:
  workflow_dispatch:
  push:
    branches: [ main ]

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check required secrets
        id: secrets
        shell: bash
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          ENV_FILE: ${{ secrets.ENV_FILE }}
          DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
        run: |
          set -euo pipefail

          missing=()
          for var in DEPLOY_HOST DEPLOY_PATH DEPLOY_USER ENV_FILE DEPLOY_SSH_KEY; do
            if [ -z "${!var:-}" ]; then
              missing+=("$var")
            fi
          done

          if [ "${#missing[@]}" -ne 0 ]; then
            printf '::warning::Skipping deploy because secrets are missing: %s\n' "${missing[*]}"
            echo "missing=true" >> "$GITHUB_OUTPUT"
          else
            echo "missing=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Abort deployment (secrets missing)
        if: steps.secrets.outputs.missing == 'true'
        run: echo "Deployment skipped because required secrets are not configured."

      # 1) Поднимаем ssh-agent и добавляем приватный ключ из секрета.
      #    Поддерживаем как исходный PEM, так и base64-строку.
      - name: Set up SSH key
        if: steps.secrets.outputs.missing != 'true'
        shell: bash
        env:
          DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
        run: |
          set -euo pipefail

          mkdir -p ~/.ssh

          key="$DEPLOY_SSH_KEY"

          if [[ "$key" == *"-----BEGIN"* ]]; then
            decoded="$key"
          else
            if ! decoded="$(printf '%s' "$key" | base64 --decode)"; then
              echo "::error::DEPLOY_SSH_KEY must be a valid PEM block or a base64-encoded PEM" >&2
              exit 1
            fi
          fi

          if [[ "$decoded" != *"-----BEGIN"* ]]; then
            echo "::error::DEPLOY_SSH_KEY does not look like a PEM-formatted key" >&2
            exit 1
          fi

          cleaned="$(printf '%s' "$decoded" | tr -d '\r')"
          if [[ "$cleaned" == *$'\n' ]]; then
            printf '%s' "$cleaned" > ~/.ssh/id_deploy
          else
            printf '%s\n' "$cleaned" > ~/.ssh/id_deploy
          fi

          chmod 600 ~/.ssh/id_deploy

          eval "$(ssh-agent -s)"
          ssh-add ~/.ssh/id_deploy
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> "$GITHUB_ENV"
          echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> "$GITHUB_ENV"
          echo "::add-mask::$SSH_AUTH_SOCK"
          echo "::add-mask::$SSH_AGENT_PID"

      # 2) Добавляем host key сервера (чтобы не было интерактива по known_hosts)
      - name: Add server to known_hosts
        if: steps.secrets.outputs.missing != 'true'
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
        run: |
          set -euo pipefail

          mkdir -p ~/.ssh
          PORT_ARGS=()
          if [ -n "${DEPLOY_PORT:-}" ]; then
            PORT_ARGS+=("-p" "$DEPLOY_PORT")
          fi
          ssh-keyscan -4 -t ed25519,rsa "${PORT_ARGS[@]}" "$DEPLOY_HOST" >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts
          # отладка: покажем запись (без секрета)
          tail -n 1 ~/.ssh/known_hosts || true

      # 3) Готовим директорию на сервере
      - name: Prepare remote dir
        if: steps.secrets.outputs.missing != 'true'
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
        run: |
          set -euo pipefail

          SSH_ARGS=("-o" "StrictHostKeyChecking=yes")
          if [ -n "${DEPLOY_PORT:-}" ]; then
            SSH_ARGS+=("-p" "$DEPLOY_PORT")
          fi

          ssh "${SSH_ARGS[@]}" "$DEPLOY_USER@$DEPLOY_HOST" \
            "sudo mkdir -p '$DEPLOY_PATH' && sudo chown -R \$USER:\$USER '$DEPLOY_PATH'"

      # 4) Копируем проект на сервер (rsync быстрее и надёжнее scp)
      - name: Upload project
        if: steps.secrets.outputs.missing != 'true'
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
        run: |
          set -euo pipefail

          SSH_CMD=(ssh "-o" "StrictHostKeyChecking=yes")
          if [ -n "${DEPLOY_PORT:-}" ]; then
            SSH_CMD+=("-p" "$DEPLOY_PORT")
          fi

          rsync -az --delete \
            --exclude '.git' \
            --exclude '.github' \
            -e "${SSH_CMD[*]}" \
            ./ "$DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH/"

      # 5) Validate ENV_FILE content before deployment
      - name: Validate environment file
        if: steps.secrets.outputs.missing != 'true'
        env:
          ENV_FILE: ${{ secrets.ENV_FILE }}
        run: |
          set -euo pipefail
          
          echo "Validating ENV_FILE secret..."
          
          # Check that BOT_TOKEN is present
          if ! echo "$ENV_FILE" | grep -q "^BOT_TOKEN="; then
            echo "::error::ENV_FILE must contain BOT_TOKEN"
            exit 1
          fi
          
          # Check that BOT_TOKEN is not empty or placeholder
          if echo "$ENV_FILE" | grep -qE "^BOT_TOKEN=(|your-|replace-|test-)"; then
            echo "::error::BOT_TOKEN appears to be a placeholder value"
            exit 1
          fi
          
          # Check for database configuration
          if ! echo "$ENV_FILE" | grep -qE "^(BOT_DATABASE_URL|POSTGRES_)"; then
            echo "::warning::No database configuration found in ENV_FILE"
          fi
          
          echo "✓ ENV_FILE validation passed"

      # 6) Write .env and deploy with improved migration handling
      - name: Deploy to server
        if: steps.secrets.outputs.missing != 'true'
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
        run: |
          set -euo pipefail

          SSH_ARGS=("-o" "StrictHostKeyChecking=yes")
          if [ -n "${DEPLOY_PORT:-}" ]; then
            SSH_ARGS+=("-p" "$DEPLOY_PORT")
          fi

          ssh "${SSH_ARGS[@]}" "$DEPLOY_USER@$DEPLOY_HOST" <<'EOSSH'
          set -euo pipefail
          cd '${{ secrets.DEPLOY_PATH }}'

          echo "=== Deployment started ==="
          
          # Write .env from secret
          cat > .env <<'EOF'
          ${{ secrets.ENV_FILE }}
          EOF
          chmod 600 .env
          echo "✓ Environment file written"

          # Stop old containers gracefully
          if sudo docker compose ps -q | grep -q .; then
            echo "Stopping existing containers..."
            sudo docker compose down
          fi

          # Pull latest images
          echo "Pulling base images..."
          sudo docker compose pull db webapp || true

          # Build and start services
          echo "Building and starting services..."
          sudo docker compose up -d --build --remove-orphans

          # Wait for services to be healthy
          echo "Waiting for services to be healthy..."
          sleep 10

          # Check service status
          echo "=== Service Status ==="
          sudo docker compose ps

          # Check bot logs for startup errors
          echo "=== Bot Logs (last 20 lines) ==="
          sudo docker compose logs --tail=20 bot

          # Verify database connection
          echo "=== Database Status ==="
          sudo docker compose exec -T db pg_isready -U ${POSTGRES_USER:-dating} || echo "⚠ Database not ready yet"

          echo "=== Deployment completed ==="
          EOSSH

      # 7) Post-deployment health check
      - name: Health check
        if: steps.secrets.outputs.missing != 'true'
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          set -euo pipefail

          SSH_ARGS=("-o" "StrictHostKeyChecking=yes")
          if [ -n "${DEPLOY_PORT:-}" ]; then
            SSH_ARGS+=("-p" "$DEPLOY_PORT")
          fi

          echo "Performing post-deployment health check..."
          
          ssh "${SSH_ARGS[@]}" "$DEPLOY_USER@$DEPLOY_HOST" <<'EOSSH'
          set -euo pipefail
          cd '${{ secrets.DEPLOY_PATH }}'

          # Check if bot container is running
          if ! sudo docker compose ps bot | grep -q "Up"; then
            echo "::error::Bot container is not running!"
            sudo docker compose logs --tail=50 bot
            exit 1
          fi

          # Check if database is running
          if ! sudo docker compose ps db | grep -q "Up"; then
            echo "::error::Database container is not running!"
            sudo docker compose logs --tail=50 db
            exit 1
          fi

          # Check for recent errors in bot logs
          if sudo docker compose logs --tail=50 bot | grep -iE "(error|exception|failed)" | grep -v "test"; then
            echo "::warning::Potential errors found in bot logs"
          fi

          echo "✓ Health check passed"
          EOSSH
