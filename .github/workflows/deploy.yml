name: Deploy

on:
  workflow_dispatch:
  push:
    branches: [ main ]

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check required secrets
        id: secrets
        shell: bash
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          ENV_FILE: ${{ secrets.ENV_FILE }}
          DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
        run: |
          set -euo pipefail

          missing=()
          for var in DEPLOY_HOST DEPLOY_PATH DEPLOY_USER ENV_FILE DEPLOY_SSH_KEY; do
            if [ -z "${!var:-}" ]; then
              missing+=("$var")
            fi
          done

          if [ "${#missing[@]}" -ne 0 ]; then
            printf '::warning::Skipping deploy because secrets are missing: %s\n' "${missing[*]}"
            echo "missing=true" >> "$GITHUB_OUTPUT"
          else
            echo "missing=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Abort deployment (secrets missing)
        if: steps.secrets.outputs.missing == 'true'
        run: echo "Deployment skipped because required secrets are not configured."

      # 1) Поднимаем ssh-agent и добавляем приватный ключ из секрета.
      #    Поддерживаем как исходный PEM, так и base64-строку.
      - name: Set up SSH key
        if: steps.secrets.outputs.missing != 'true'
        shell: bash
        env:
          DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
        run: |
          set -euo pipefail

          mkdir -p ~/.ssh

          key="$DEPLOY_SSH_KEY"

          if [[ "$key" == *"-----BEGIN"* ]]; then
            decoded="$key"
          else
            if ! decoded="$(printf '%s' "$key" | base64 --decode)"; then
              echo "::error::DEPLOY_SSH_KEY must be a valid PEM block or a base64-encoded PEM" >&2
              exit 1
            fi
          fi

          if [[ "$decoded" != *"-----BEGIN"* ]]; then
            echo "::error::DEPLOY_SSH_KEY does not look like a PEM-formatted key" >&2
            exit 1
          fi

          cleaned="$(printf '%s' "$decoded" | tr -d '\r')"
          if [[ "$cleaned" == *$'\n' ]]; then
            printf '%s' "$cleaned" > ~/.ssh/id_deploy
          else
            printf '%s\n' "$cleaned" > ~/.ssh/id_deploy
          fi

          chmod 600 ~/.ssh/id_deploy

          eval "$(ssh-agent -s)"
          ssh-add ~/.ssh/id_deploy
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> "$GITHUB_ENV"
          echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> "$GITHUB_ENV"
          echo "::add-mask::$SSH_AUTH_SOCK"
          echo "::add-mask::$SSH_AGENT_PID"

      # 2) Добавляем host key сервера (чтобы не было интерактива по known_hosts)
      - name: Add server to known_hosts
        if: steps.secrets.outputs.missing != 'true'
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
        run: |
          set -euo pipefail

          mkdir -p ~/.ssh
          PORT_ARGS=()
          if [ -n "${DEPLOY_PORT:-}" ]; then
            PORT_ARGS+=("-p" "$DEPLOY_PORT")
          fi
          ssh-keyscan -4 -t ed25519,rsa "${PORT_ARGS[@]}" "$DEPLOY_HOST" >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts
          # отладка: покажем запись (без секрета)
          tail -n 1 ~/.ssh/known_hosts || true

      # 3) Готовим директорию на сервере
      - name: Prepare remote dir
        if: steps.secrets.outputs.missing != 'true'
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
        run: |
          set -euo pipefail

          SSH_ARGS=("-o" "StrictHostKeyChecking=yes")
          if [ -n "${DEPLOY_PORT:-}" ]; then
            SSH_ARGS+=("-p" "$DEPLOY_PORT")
          fi

          ssh "${SSH_ARGS[@]}" "$DEPLOY_USER@$DEPLOY_HOST" \
            "sudo mkdir -p '$DEPLOY_PATH' && sudo chown -R \$USER:\$USER '$DEPLOY_PATH'"

      # 4) Копируем проект на сервер (rsync быстрее и надёжнее scp)
      - name: Upload project
        if: steps.secrets.outputs.missing != 'true'
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
        run: |
          set -euo pipefail

          SSH_CMD=(ssh "-o" "StrictHostKeyChecking=yes")
          if [ -n "${DEPLOY_PORT:-}" ]; then
            SSH_CMD+=("-p" "$DEPLOY_PORT")
          fi

          rsync -az --delete \
            --exclude '.git' \
            --exclude '.github' \
            -e "${SSH_CMD[*]}" \
            ./ "$DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH/"

      # 5) Пишем .env и запускаем docker compose
      - name: Write .env and compose up
        if: steps.secrets.outputs.missing != 'true'
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
        run: |
          set -euo pipefail

          SSH_ARGS=("-o" "StrictHostKeyChecking=yes")
          if [ -n "${DEPLOY_PORT:-}" ]; then
            SSH_ARGS+=("-p" "$DEPLOY_PORT")
          fi

          ssh "${SSH_ARGS[@]}" "$DEPLOY_USER@$DEPLOY_HOST" <<'EOSSH'
          set -euo pipefail
          cd '${{ secrets.DEPLOY_PATH }}'

          # пишем .env из секрета
          cat > .env <<'EOF'
          ${{ secrets.ENV_FILE }}
          EOF
          chmod 600 .env

          # деплой
          sudo docker compose up -d --build
          sudo docker compose ps
          EOSSH
