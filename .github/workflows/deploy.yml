name: Deploy

on:
  workflow_dispatch:
  push:
    branches: [ main ]

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check required secrets
        id: secrets
        shell: bash
        env:
          DEPLOY_HOST_SECRET: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_HOST_VAR: ${{ vars.DEPLOY_HOST }}
          DEPLOY_PATH_SECRET: ${{ secrets.DEPLOY_PATH }}
          DEPLOY_PATH_VAR: ${{ vars.DEPLOY_PATH }}
          DEPLOY_USER_SECRET: ${{ secrets.DEPLOY_USER }}
          DEPLOY_USERNAME_SECRET: ${{ secrets.DEPLOY_USERNAME }}
          DEPLOY_USER_VAR: ${{ vars.DEPLOY_USER }}
          DEPLOY_USERNAME_VAR: ${{ vars.DEPLOY_USERNAME }}
          ENV_FILE_SECRET: ${{ secrets.ENV_FILE }}
          ENV_FILE_VAR: ${{ vars.ENV_FILE }}
          DEPLOY_SSH_KEY_SECRET: ${{ secrets.DEPLOY_SSH_KEY }}
          DEPLOY_SSH_KEY_VAR: ${{ vars.DEPLOY_SSH_KEY }}
          DEPLOY_PORT_SECRET: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_PORT_VAR: ${{ vars.DEPLOY_PORT }}
        run: |
          set -euo pipefail

          declare -A outputs=()
          missing=()

          resolve() {
            local candidate
            for candidate in "$@"; do
              if [ -n "${!candidate:-}" ]; then
                printf '%s' "${!candidate}"
                return 0
              fi
            done
            return 1
          }

          require() {
            local display="$1"
            shift
            local output_name="${display,,}"
            local value
            if value="$(resolve "$@")"; then
              outputs["$output_name"]="$value"
            else
              missing+=("$display")
            fi
          }

          optional() {
            local display="$1"
            shift
            local output_name="${display,,}"
            local value
            if value="$(resolve "$@")"; then
              outputs["$output_name"]="$value"
            fi
          }

          require DEPLOY_HOST DEPLOY_HOST_SECRET DEPLOY_HOST_VAR
          require DEPLOY_PATH DEPLOY_PATH_SECRET DEPLOY_PATH_VAR
          require DEPLOY_USER DEPLOY_USER_SECRET DEPLOY_USERNAME_SECRET DEPLOY_USER_VAR DEPLOY_USERNAME_VAR
          require ENV_FILE ENV_FILE_SECRET ENV_FILE_VAR
          require DEPLOY_SSH_KEY DEPLOY_SSH_KEY_SECRET DEPLOY_SSH_KEY_VAR
          optional DEPLOY_PORT DEPLOY_PORT_SECRET DEPLOY_PORT_VAR

          if [ "${#missing[@]}" -ne 0 ]; then
            printf '::warning::Skipping deploy because secrets are missing: %s\n' "${missing[*]}"
            echo "missing=true" >> "$GITHUB_OUTPUT"
          else
            echo "missing=false" >> "$GITHUB_OUTPUT"
          fi

          for key in DEPLOY_HOST DEPLOY_PATH DEPLOY_USER DEPLOY_SSH_KEY DEPLOY_PORT ENV_FILE; do
            local_name="${key,,}"
            value="${outputs[$local_name]:-}"
            if [ -z "$value" ]; then
              continue
            fi

            case "$value" in
              *$'\n'* )
                {
                  printf '%s<<EOF\n' "$local_name"
                  printf '%s\n' "$value"
                  printf 'EOF\n'
                } >> "$GITHUB_OUTPUT"
                ;;
              * )
                printf '%s=%s\n' "$local_name" "$value" >> "$GITHUB_OUTPUT"
                ;;
            esac
          done

      - name: Abort deployment (secrets missing)
        if: steps.secrets.outputs.missing == 'true'
        run: echo "Deployment skipped because required secrets are not configured."

      # 1) Поднимаем ssh-agent и добавляем приватный ключ из секрета.
      #    Поддерживаем как исходный PEM, так и base64-строку.
      - name: Set up SSH key
        if: steps.secrets.outputs.missing != 'true'
        shell: bash
        env:
          DEPLOY_SSH_KEY: ${{ steps.secrets.outputs.deploy_ssh_key }}
        run: |
          set -euo pipefail

          mkdir -p ~/.ssh

          python - <<'PY'
          import base64
          import binascii
          import os
          import sys

          key = os.environ["DEPLOY_SSH_KEY"].strip()

          if "-----BEGIN" in key:
              data = key
          else:
              try:
                  decoded = base64.b64decode(key, validate=True)
              except binascii.Error as exc:
                  print("::error::DEPLOY_SSH_KEY must be a valid PEM block or a base64-encoded PEM", file=sys.stderr)
                  raise SystemExit(1) from exc
              try:
                  data = decoded.decode("utf-8")
              except UnicodeDecodeError as exc:
                  print("::error::Decoded DEPLOY_SSH_KEY is not valid UTF-8 text", file=sys.stderr)
                  raise SystemExit(1) from exc

          if "-----BEGIN" not in data:
              print("::error::DEPLOY_SSH_KEY does not look like a PEM-formatted key", file=sys.stderr)
              raise SystemExit(1)

          data = data.replace("\r\n", "\n").rstrip("\n") + "\n"

          path = os.path.expanduser("~/.ssh/id_deploy")
          with open(path, "w", encoding="utf-8") as fh:
              fh.write(data)
          PY

          chmod 600 ~/.ssh/id_deploy

          eval "$(ssh-agent -s)"
          ssh-add ~/.ssh/id_deploy
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> "$GITHUB_ENV"
          echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> "$GITHUB_ENV"
          echo "::add-mask::$SSH_AUTH_SOCK"
          echo "::add-mask::$SSH_AGENT_PID"

      # 2) Добавляем host key сервера (чтобы не было интерактива по known_hosts)
      - name: Add server to known_hosts
        if: steps.secrets.outputs.missing != 'true'
        env:
          DEPLOY_HOST: ${{ steps.secrets.outputs.deploy_host }}
          DEPLOY_PORT: ${{ steps.secrets.outputs.deploy_port }}
        run: |
          set -euo pipefail

          mkdir -p ~/.ssh
          PORT_ARGS=()
          if [ -n "${DEPLOY_PORT:-}" ]; then
            PORT_ARGS+=("-p" "$DEPLOY_PORT")
          fi
          ssh-keyscan -4 -t ed25519,rsa "${PORT_ARGS[@]}" "$DEPLOY_HOST" >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts
          # отладка: покажем запись (без секрета)
          tail -n 1 ~/.ssh/known_hosts || true

      # 3) Готовим директорию на сервере
      - name: Prepare remote dir
        if: steps.secrets.outputs.missing != 'true'
        env:
          DEPLOY_HOST: ${{ steps.secrets.outputs.deploy_host }}
          DEPLOY_PATH: ${{ steps.secrets.outputs.deploy_path }}
          DEPLOY_PORT: ${{ steps.secrets.outputs.deploy_port }}
          DEPLOY_USER: ${{ steps.secrets.outputs.deploy_user }}
        run: |
          set -euo pipefail

          SSH_ARGS=("-o" "StrictHostKeyChecking=yes")
          if [ -n "${DEPLOY_PORT:-}" ]; then
            SSH_ARGS+=("-p" "$DEPLOY_PORT")
          fi

          ssh "${SSH_ARGS[@]}" "$DEPLOY_USER@$DEPLOY_HOST" \
            "sudo mkdir -p '$DEPLOY_PATH' && sudo chown -R \$USER:\$USER '$DEPLOY_PATH'"

      # 4) Копируем проект на сервер (rsync быстрее и надёжнее scp)
      - name: Upload project
        if: steps.secrets.outputs.missing != 'true'
        env:
          DEPLOY_HOST: ${{ steps.secrets.outputs.deploy_host }}
          DEPLOY_PATH: ${{ steps.secrets.outputs.deploy_path }}
          DEPLOY_PORT: ${{ steps.secrets.outputs.deploy_port }}
          DEPLOY_USER: ${{ steps.secrets.outputs.deploy_user }}
        run: |
          set -euo pipefail

          SSH_CMD=(ssh "-o" "StrictHostKeyChecking=yes")
          if [ -n "${DEPLOY_PORT:-}" ]; then
            SSH_CMD+=("-p" "$DEPLOY_PORT")
          fi

          rsync -az --delete \
            --exclude '.git' \
            --exclude '.github' \
            -e "${SSH_CMD[*]}" \
            ./ "$DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH/"

      # 5) Пишем .env и запускаем docker compose
      - name: Write .env and compose up
        if: steps.secrets.outputs.missing != 'true'
        env:
          DEPLOY_HOST: ${{ steps.secrets.outputs.deploy_host }}
          DEPLOY_PATH: ${{ steps.secrets.outputs.deploy_path }}
          DEPLOY_PORT: ${{ steps.secrets.outputs.deploy_port }}
          DEPLOY_USER: ${{ steps.secrets.outputs.deploy_user }}
        run: |
          set -euo pipefail

          SSH_ARGS=("-o" "StrictHostKeyChecking=yes")
          if [ -n "${DEPLOY_PORT:-}" ]; then
            SSH_ARGS+=("-p" "$DEPLOY_PORT")
          fi

          ssh "${SSH_ARGS[@]}" "$DEPLOY_USER@$DEPLOY_HOST" <<'EOSSH'
          set -euo pipefail
          cd '${{ steps.secrets.outputs.deploy_path }}'

          # пишем .env из секрета
          cat > .env <<'EOF'
          ${{ steps.secrets.outputs.env_file }}
          EOF
          chmod 600 .env

          # деплой
          sudo docker compose up -d --build
          sudo docker compose ps
          EOSSH
