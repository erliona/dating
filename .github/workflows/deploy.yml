name: Deploy

on:
  workflow_dispatch:
  push:
    branches: [ main ]

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check required secrets
        id: secrets
        shell: bash
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
        run: |
          set -euo pipefail

          missing=()
          for var in DEPLOY_HOST DEPLOY_USER DEPLOY_SSH_KEY BOT_TOKEN; do
            if [ -z "${!var:-}" ]; then
              missing+=("$var")
            fi
          done

          if [ "${#missing[@]}" -ne 0 ]; then
            printf '::warning::Skipping deploy because required secrets are missing: %s\n' "${missing[*]}"
            echo "missing=true" >> "$GITHUB_OUTPUT"
          else
            echo "missing=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Abort deployment (secrets missing)
        if: steps.secrets.outputs.missing == 'true'
        run: |
          echo "‚ùå Deployment skipped because required secrets are not configured."
          echo ""
          echo "Required secrets (3 core + BOT_TOKEN):"
          echo "  - DEPLOY_HOST    : IP or hostname of your server"
          echo "  - DEPLOY_USER    : SSH user with sudo permissions"
          echo "  - DEPLOY_SSH_KEY : Private SSH key for authentication"
          echo "  - BOT_TOKEN      : Telegram bot token from @BotFather"
          echo ""
          echo "Optional secrets for HTTPS (recommended for production):"
          echo "  - DOMAIN         : Your domain name (e.g., example.com)"
          echo "  - ACME_EMAIL     : Email for Let's Encrypt notifications"
          echo ""
          echo "Configure these in: Settings ‚Üí Secrets and variables ‚Üí Actions"

      # 1) –ü–æ–¥–Ω–∏–º–∞–µ–º ssh-agent –∏ –¥–æ–±–∞–≤–ª—è–µ–º –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –∏–∑ —Å–µ–∫—Ä–µ—Ç–∞.
      #    –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º –∫–∞–∫ –∏—Å—Ö–æ–¥–Ω—ã–π PEM, —Ç–∞–∫ –∏ base64-—Å—Ç—Ä–æ–∫—É.
      - name: Set up SSH key
        if: steps.secrets.outputs.missing != 'true'
        shell: bash
        env:
          DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
        run: |
          set -euo pipefail

          mkdir -p ~/.ssh

          key="$DEPLOY_SSH_KEY"

          if [[ "$key" == *"-----BEGIN"* ]]; then
            decoded="$key"
          else
            if ! decoded="$(printf '%s' "$key" | base64 --decode)"; then
              echo "::error::DEPLOY_SSH_KEY must be a valid PEM block or a base64-encoded PEM" >&2
              exit 1
            fi
          fi

          if [[ "$decoded" != *"-----BEGIN"* ]]; then
            echo "::error::DEPLOY_SSH_KEY does not look like a PEM-formatted key" >&2
            exit 1
          fi

          cleaned="$(printf '%s' "$decoded" | tr -d '\r')"
          if [[ "$cleaned" == *$'\n' ]]; then
            printf '%s' "$cleaned" > ~/.ssh/id_deploy
          else
            printf '%s\n' "$cleaned" > ~/.ssh/id_deploy
          fi

          chmod 600 ~/.ssh/id_deploy

          eval "$(ssh-agent -s)"
          ssh-add ~/.ssh/id_deploy
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> "$GITHUB_ENV"
          echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> "$GITHUB_ENV"
          echo "::add-mask::$SSH_AUTH_SOCK"
          echo "::add-mask::$SSH_AGENT_PID"

      # 2) –î–æ–±–∞–≤–ª—è–µ–º host key —Å–µ—Ä–≤–µ—Ä–∞ (—á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–∞ –ø–æ known_hosts)
      - name: Add server to known_hosts
        if: steps.secrets.outputs.missing != 'true'
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
        run: |
          set -euo pipefail

          mkdir -p ~/.ssh
          PORT_ARGS=()
          if [ -n "${DEPLOY_PORT:-}" ]; then
            PORT_ARGS+=("-p" "$DEPLOY_PORT")
          fi
          ssh-keyscan -4 -t ed25519,rsa "${PORT_ARGS[@]}" "$DEPLOY_HOST" >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts
          # –æ—Ç–ª–∞–¥–∫–∞: –ø–æ–∫–∞–∂–µ–º –∑–∞–ø–∏—Å—å (–±–µ–∑ —Å–µ–∫—Ä–µ—Ç–∞)
          tail -n 1 ~/.ssh/known_hosts || true

      # 3) –ì–æ—Ç–æ–≤–∏–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ –∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º Docker –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
      - name: Prepare server
        if: steps.secrets.outputs.missing != 'true'
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
        run: |
          set -euo pipefail

          SSH_ARGS=("-o" "StrictHostKeyChecking=yes")
          if [ -n "${DEPLOY_PORT:-}" ]; then
            SSH_ARGS+=("-p" "$DEPLOY_PORT")
          fi

          DEPLOY_PATH_ACTUAL="${DEPLOY_PATH:-/opt/dating}"
          
          echo "üì¶ Preparing server at $DEPLOY_HOST:$DEPLOY_PATH_ACTUAL"

          ssh "${SSH_ARGS[@]}" "$DEPLOY_USER@$DEPLOY_HOST" bash -s <<'EOSSH'
          set -euo pipefail
          
          DEPLOY_PATH="${DEPLOY_PATH:-/opt/dating}"
          
          echo "=== Server Preparation Started ==="
          
          # Create deployment directory
          echo "üìÅ Creating deployment directory: $DEPLOY_PATH"
          sudo mkdir -p "$DEPLOY_PATH"
          sudo chown -R "$USER:$USER" "$DEPLOY_PATH"
          
          # Check and install Docker
          if ! command -v docker >/dev/null 2>&1; then
            echo "üêã Docker not found. Installing Docker..."
            curl -fsSL https://get.docker.com -o /tmp/get-docker.sh
            sudo sh /tmp/get-docker.sh
            rm /tmp/get-docker.sh
            
            # Add current user to docker group
            sudo usermod -aG docker "$USER"
            echo "‚úì Docker installed successfully"
          else
            echo "‚úì Docker is already installed"
            docker --version
          fi
          
          # Check and install Docker Compose plugin
          if ! docker compose version >/dev/null 2>&1; then
            echo "üîß Installing Docker Compose plugin..."
            COMPOSE_VERSION="v2.24.7"
            sudo mkdir -p /usr/local/lib/docker/cli-plugins
            sudo curl -SL "https://github.com/docker/compose/releases/download/${COMPOSE_VERSION}/docker-compose-linux-x86_64" \
              -o /usr/local/lib/docker/cli-plugins/docker-compose
            sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
            echo "‚úì Docker Compose plugin installed successfully"
          else
            echo "‚úì Docker Compose plugin is already installed"
            docker compose version
          fi
          
          # Ensure docker service is running
          if ! sudo systemctl is-active --quiet docker; then
            echo "üöÄ Starting Docker service..."
            sudo systemctl start docker
            sudo systemctl enable docker
          fi
          
          echo "=== Server Preparation Completed ==="
          EOSSH

      # 4) –ö–æ–ø–∏—Ä—É–µ–º –ø—Ä–æ–µ–∫—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä (rsync –±—ã—Å—Ç—Ä–µ–µ –∏ –Ω–∞–¥—ë–∂–Ω–µ–µ scp)
      - name: Upload project
        if: steps.secrets.outputs.missing != 'true'
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
        run: |
          set -euo pipefail

          SSH_CMD=(ssh "-o" "StrictHostKeyChecking=yes")
          if [ -n "${DEPLOY_PORT:-}" ]; then
            SSH_CMD+=("-p" "$DEPLOY_PORT")
          fi

          DEPLOY_PATH_ACTUAL="${DEPLOY_PATH:-/opt/dating}"
          
          echo "üì§ Uploading project to $DEPLOY_HOST:$DEPLOY_PATH_ACTUAL"

          rsync -az --delete \
            --exclude '.git' \
            --exclude '.github' \
            -e "${SSH_CMD[*]}" \
            ./ "$DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH_ACTUAL/"
          
          echo "‚úì Project uploaded successfully"

      # 5) Generate .env file from secrets
      - name: Generate environment file
        if: steps.secrets.outputs.missing != 'true'
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
          DOMAIN: ${{ secrets.DOMAIN }}
          ACME_EMAIL: ${{ secrets.ACME_EMAIL }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          ACME_CA_SERVER: ${{ secrets.ACME_CA_SERVER }}
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          set -euo pipefail
          
          echo "üîß Generating environment configuration"
          
          # SSH setup for retrieving existing password
          SSH_ARGS=("-o" "StrictHostKeyChecking=yes")
          if [ -n "${DEPLOY_PORT:-}" ]; then
            SSH_ARGS+=("-p" "$DEPLOY_PORT")
          fi
          
          DEPLOY_PATH_ACTUAL="${DEPLOY_PATH:-/opt/dating}"
          
          # Try to get existing POSTGRES_PASSWORD from server to avoid database connection issues
          EXISTING_PASSWORD=""
          echo "üîç Checking for existing database password on server..."
          if ssh "${SSH_ARGS[@]}" "$DEPLOY_USER@$DEPLOY_HOST" "test -f $DEPLOY_PATH_ACTUAL/.env" 2>/dev/null; then
            EXISTING_PASSWORD=$(ssh "${SSH_ARGS[@]}" "$DEPLOY_USER@$DEPLOY_HOST" "grep '^POSTGRES_PASSWORD=' $DEPLOY_PATH_ACTUAL/.env 2>/dev/null | cut -d'=' -f2-" || echo "")
            if [ -n "$EXISTING_PASSWORD" ]; then
              echo "‚úì Found existing database password, reusing it to maintain database connectivity"
            else
              echo "‚ö†Ô∏è  .env file exists but no POSTGRES_PASSWORD found"
            fi
          else
            echo "‚ÑπÔ∏è  No .env file found on server (first deployment)"
          fi
          
          # Use existing password if found, otherwise use secret or generate new one
          if [ -n "$EXISTING_PASSWORD" ]; then
            POSTGRES_PASSWORD_TO_USE="$EXISTING_PASSWORD"
            echo "Using existing password from server"
          elif [ -n "${POSTGRES_PASSWORD:-}" ]; then
            POSTGRES_PASSWORD_TO_USE="$POSTGRES_PASSWORD"
            echo "Using password from GitHub secret"
          else
            POSTGRES_PASSWORD_TO_USE="$(openssl rand -base64 32 | tr -dc 'A-Za-z0-9' | head -c 32)"
            echo "‚ö†Ô∏è  Generated new random database password"
            echo "‚ö†Ô∏è  Database will be reset if it already exists with a different password"
          fi
          
          # Generate .env file with smart defaults
          cat > /tmp/deploy.env <<EOF
          # Bot Configuration (Required)
          BOT_TOKEN=${BOT_TOKEN}

          # Database Configuration
          POSTGRES_DB=${POSTGRES_DB:-dating}
          POSTGRES_USER=${POSTGRES_USER:-dating}
          POSTGRES_PASSWORD=${POSTGRES_PASSWORD_TO_USE}

          # HTTPS Configuration (Production)
          EOF

          # Add HTTPS config if DOMAIN is provided
          if [ -n "${DOMAIN:-}" ]; then
            echo "DOMAIN=${DOMAIN}" >> /tmp/deploy.env
            echo "WEBAPP_URL=https://${DOMAIN}" >> /tmp/deploy.env
            echo "ACME_EMAIL=${ACME_EMAIL:-admin@${DOMAIN}}" >> /tmp/deploy.env
            
            # Add staging CA server if specified
            if [ -n "${ACME_CA_SERVER:-}" ]; then
              echo "ACME_CA_SERVER=${ACME_CA_SERVER}" >> /tmp/deploy.env
            fi
            
            echo "‚úì HTTPS configuration enabled for domain: ${DOMAIN}"
          else
            echo "DOMAIN=localhost" >> /tmp/deploy.env
            echo "WEBAPP_URL=https://localhost" >> /tmp/deploy.env
            echo "‚ö†Ô∏è  No DOMAIN specified - using localhost (HTTPS certificates won't be issued)"
          fi
          
          echo ""
          echo "üìã Generated configuration:"
          grep -v "PASSWORD\|TOKEN" /tmp/deploy.env || true
          
      # 6) Validate environment configuration
      - name: Validate configuration
        if: steps.secrets.outputs.missing != 'true'
        env:
          DOMAIN: ${{ secrets.DOMAIN }}
        run: |
          set -euo pipefail
          
          echo "‚úÖ Validating deployment configuration..."
          
          # Extract BOT_TOKEN from the generated .env file
          BOT_TOKEN_VALUE=$(grep "^BOT_TOKEN=" /tmp/deploy.env | cut -d'=' -f2-)
          
          # Check that BOT_TOKEN is not empty
          if [ -z "$BOT_TOKEN_VALUE" ]; then
            echo "::error::BOT_TOKEN is empty"
            exit 1
          fi
          
          # Check for common placeholder patterns
          if echo "$BOT_TOKEN_VALUE" | grep -qiE "(your-|replace-|insert-|paste-|add-|enter-|example|placeholder|token-here|bot-token|from-botfather)"; then
            echo "::error::BOT_TOKEN appears to be a placeholder value"
            echo ""
            echo "The BOT_TOKEN secret contains a placeholder value like:"
            echo "  - 'your-telegram-bot-token-here'"
            echo "  - 'replace-me-with-token'"
            echo "  - 'insert-token-here'"
            echo ""
            echo "Please set a real Telegram bot token in GitHub Secrets."
            echo ""
            echo "How to get a valid token:"
            echo "  1. Open Telegram and search for @BotFather"
            echo "  2. Send /newbot and follow the instructions"
            echo "  3. Copy the token (format: 123456789:ABCdefGHIjkl...)"
            echo "  4. Go to: Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "  5. Update the BOT_TOKEN secret with your real token"
            echo ""
            exit 1
          fi
          
          # Validate Telegram bot token format: <numeric_id>:<alphanumeric_hash>
          if ! echo "$BOT_TOKEN_VALUE" | grep -qE "^[0-9]+:[A-Za-z0-9_-]+$"; then
            echo "::error::BOT_TOKEN has invalid format"
            echo ""
            echo "Telegram bot tokens must match the format:"
            echo "  <numeric_id>:<alphanumeric_hash>"
            echo ""
            echo "Example: 123456789:ABCdefGHIjklMNOpqrsTUVwxyz-1234567"
            echo ""
            echo "Your token appears to be malformed. Please check that you copied"
            echo "the complete token from @BotFather on Telegram."
            echo ""
            exit 1
          fi
          
          # Warn if no domain for production
          if [ -z "${DOMAIN:-}" ]; then
            echo "::warning::Deploying without DOMAIN - HTTPS certificates won't be issued"
            echo "::warning::For production, set DOMAIN secret to your domain name"
          fi
          
          echo "‚úì Configuration validation passed"

      # 7) Deploy to server with generated .env
      - name: Deploy to server
        if: steps.secrets.outputs.missing != 'true'
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
        run: |
          set -euo pipefail

          SSH_ARGS=("-o" "StrictHostKeyChecking=yes")
          if [ -n "${DEPLOY_PORT:-}" ]; then
            SSH_ARGS+=("-p" "$DEPLOY_PORT")
          fi

          DEPLOY_PATH_ACTUAL="${DEPLOY_PATH:-/opt/dating}"
          
          echo "üöÄ Deploying application to $DEPLOY_HOST:$DEPLOY_PATH_ACTUAL"

          # Upload .env file
          scp "${SSH_ARGS[@]}" /tmp/deploy.env "$DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH_ACTUAL/.env"
          
          # Deploy and start services
          ssh "${SSH_ARGS[@]}" "$DEPLOY_USER@$DEPLOY_HOST" bash -s <<'EOSSH'
          set -euo pipefail
          
          DEPLOY_PATH="${DEPLOY_PATH:-/opt/dating}"
          cd "$DEPLOY_PATH"

          echo "=== Deployment Started ==="
          
          # Secure .env file
          chmod 600 .env
          echo "‚úì Environment file secured"

          # Helper function to run docker with sudo if needed
          run_docker() {
            # Try without sudo first (if user is in docker group)
            if docker "$@" 2>/dev/null; then
              return 0
            fi
            # Fall back to sudo
            sudo docker "$@"
          }

          # Check if database password has changed
          PASSWORD_CHANGED=false
          VOLUME_EXISTS=false
          
          # Check if database volume exists
          if run_docker volume inspect dating_postgres_data >/dev/null 2>&1; then
            VOLUME_EXISTS=true
          fi
          
          if [ -f .env.previous ]; then
            OLD_PASSWORD=$(grep "^POSTGRES_PASSWORD=" .env.previous 2>/dev/null | cut -d'=' -f2- || echo "")
            NEW_PASSWORD=$(grep "^POSTGRES_PASSWORD=" .env 2>/dev/null | cut -d'=' -f2- || echo "")
            if [ -n "$OLD_PASSWORD" ] && [ -n "$NEW_PASSWORD" ] && [ "$OLD_PASSWORD" != "$NEW_PASSWORD" ]; then
              echo "‚ö†Ô∏è  Database password has changed!"
              PASSWORD_CHANGED=true
            fi
          elif [ "$VOLUME_EXISTS" = true ]; then
            # No .env.previous but volume exists - this is a problem!
            # The volume has an unknown password, so we must recreate it
            echo "‚ö†Ô∏è  Database volume exists but no .env.previous file found!"
            echo "‚ö†Ô∏è  This usually means .env was deleted but database wasn't."
            echo "‚ö†Ô∏è  Database will be reset to avoid authentication failures."
            PASSWORD_CHANGED=true
          fi

          # Stop old containers gracefully
          if run_docker compose ps -q 2>/dev/null | grep -q .; then
            echo "üõë Stopping existing containers..."
            run_docker compose down
          fi

          # If password changed, we need to reset the database volume
          # because PostgreSQL only uses POSTGRES_PASSWORD on initial DB creation
          if [ "$PASSWORD_CHANGED" = true ]; then
            echo "üóëÔ∏è  Removing database volume due to password change..."
            run_docker volume rm dating_postgres_data 2>/dev/null || true
            echo "‚úì Database will be recreated with new password"
          fi

          # Save current .env as .env.previous for next deployment
          cp .env .env.previous

          # Pull latest base images
          echo "üì• Pulling base images..."
          run_docker compose pull db webapp traefik || true

          # Build and start services (with monitoring stack)
          echo "üèóÔ∏è  Building and starting services (including monitoring)..."
          run_docker compose --profile monitoring up -d --build --remove-orphans

          # Wait for services to be healthy
          echo "‚è≥ Waiting for services to start..."
          sleep 15

          # Check service status
          echo ""
          echo "=== Service Status ==="
          run_docker compose ps

          # Check bot logs for startup
          echo ""
          echo "=== Bot Startup Logs ==="
          run_docker compose logs --tail=30 bot

          # Verify database
          echo ""
          echo "=== Database Status ==="
          if run_docker compose exec -T db pg_isready -U "${POSTGRES_USER:-dating}" 2>/dev/null; then
            echo "‚úì Database is ready"
          else
            echo "‚ö†Ô∏è  Database health check unavailable (may still be starting)"
          fi

          # Verify monitoring stack is running
          echo ""
          echo "=== Monitoring Stack Status ==="
          MONITORING_SERVICES="prometheus grafana loki promtail cadvisor node-exporter postgres-exporter"
          MONITORING_OK=true
          
          for service in $MONITORING_SERVICES; do
            if run_docker compose ps "$service" 2>/dev/null | grep -q "Up"; then
              echo "‚úì $service is running"
            else
              echo "‚ö†Ô∏è  $service is not running (may not be required)"
              MONITORING_OK=false
            fi
          done
          
          if [ "$MONITORING_OK" = true ]; then
            echo "‚úÖ All monitoring services are running"
          else
            echo "‚ö†Ô∏è  Some monitoring services are not running"
            echo "Run 'docker compose --profile monitoring up -d' to start them"
          fi

          # Cleanup old images
          echo ""
          echo "üßπ Cleaning up old images..."
          run_docker image prune -f || true

          echo ""
          echo "=== Deployment Completed Successfully ==="
          echo ""
          echo "üìä Access your monitoring dashboards:"
          echo "  - Grafana:    http://${DEPLOY_HOST}:3000 (admin/admin)"
          echo "  - Prometheus: http://${DEPLOY_HOST}:9090"
          echo ""
          EOSSH
          
          echo ""
          echo "‚úÖ Deployment finished!"

      # 8) Post-deployment health check
      - name: Health check
        if: steps.secrets.outputs.missing != 'true'
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          set -euo pipefail

          SSH_ARGS=("-o" "StrictHostKeyChecking=yes")
          if [ -n "${DEPLOY_PORT:-}" ]; then
            SSH_ARGS+=("-p" "$DEPLOY_PORT")
          fi

          DEPLOY_PATH_ACTUAL="${DEPLOY_PATH:-/opt/dating}"

          echo "üè• Performing post-deployment health check..."
          
          ssh "${SSH_ARGS[@]}" "$DEPLOY_USER@$DEPLOY_HOST" bash -s <<'EOSSH'
          set -euo pipefail
          
          DEPLOY_PATH="${DEPLOY_PATH:-/opt/dating}"
          cd "$DEPLOY_PATH"

          run_docker() {
            if docker "$@" 2>/dev/null; then
              return 0
            fi
            sudo docker "$@"
          }

          # Check if bot container is running
          if ! run_docker compose ps bot | grep -q "Up"; then
            echo "::error::Bot container is not running!"
            run_docker compose logs --tail=50 bot
            exit 1
          fi

          # Check if database is running
          if ! run_docker compose ps db | grep -q "Up"; then
            echo "::error::Database container is not running!"
            run_docker compose logs --tail=50 db
            exit 1
          fi

          # Check for critical errors in bot logs
          if run_docker compose logs --tail=50 bot | grep -iE "(critical|fatal)" | grep -v "test"; then
            echo "::warning::Critical errors found in bot logs"
          fi

          # Check monitoring services
          echo ""
          echo "=== Monitoring Services Health Check ==="
          MONITORING_HEALTHY=true
          
          # Check Grafana
          if run_docker compose ps grafana | grep -q "Up"; then
            echo "‚úì Grafana is running"
          else
            echo "::warning::Grafana is not running"
            MONITORING_HEALTHY=false
          fi
          
          # Check Loki
          if run_docker compose ps loki | grep -q "Up"; then
            echo "‚úì Loki is running"
          else
            echo "::warning::Loki is not running"
            MONITORING_HEALTHY=false
          fi
          
          # Check Promtail
          if run_docker compose ps promtail | grep -q "Up"; then
            echo "‚úì Promtail is running"
          else
            echo "::warning::Promtail is not running"
            MONITORING_HEALTHY=false
          fi
          
          # Check Prometheus
          if run_docker compose ps prometheus | grep -q "Up"; then
            echo "‚úì Prometheus is running"
          else
            echo "::warning::Prometheus is not running"
            MONITORING_HEALTHY=false
          fi
          
          if [ "$MONITORING_HEALTHY" = true ]; then
            echo "‚úÖ All monitoring services are healthy"
          else
            echo "::warning::Some monitoring services are not running properly"
          fi

          echo "‚úÖ Health check passed - all core services are running"
          EOSSH
